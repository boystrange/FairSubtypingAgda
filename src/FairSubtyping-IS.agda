-- MIT License

-- Copyright (c) 2021 Luca Ciccone and Luca Padovani

-- Permission is hereby granted, free of charge, to any person
-- obtaining a copy of this software and associated documentation
-- files (the "Software"), to deal in the Software without
-- restriction, including without limitation the rights to use,
-- copy, modify, merge, publish, distribute, sublicense, and/or sell
-- copies of the Software, and to permit persons to whom the
-- Software is furnished to do so, subject to the following
-- conditions:

-- The above copyright notice and this permission notice shall be
-- included in all copies or substantial portions of the Software.

-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
-- OTHER DEALINGS IN THE SOFTWARE.

{-# OPTIONS --guardedness --sized-types #-}

open import Data.Product
open import Data.Empty
open import Data.Sum
open import Data.Vec
open import Data.List as List
open import Data.Unit
open import Data.Fin
open import Data.Bool renaming (Bool to ùîπ)
open import Relation.Unary using (_‚àà_; _‚äÜ_;_‚àâ_)
open import Relation.Binary.Construct.Closure.ReflexiveTransitive
open import Relation.Binary.PropositionalEquality
open import Relation.Nullary
open import Size
open import Codata.Thunk

open import is-lib.InfSys
open import Common using (Message)

module FairSubtyping-IS {ùïã : Set} (message : Message ùïã) where

  open Message message
  open import SessionType message
  open import Session message
  open import Transitions message
  open import Convergence message
  open import Divergence message
  open import Discriminator message
  open import Action message using (Action)
  open import Subtyping message
  open import FairSubtyping message as FS
  open import HasTrace message
  open import Compliance message
  open import FairCompliance message
  open import Trace message
  open import FairCompliance-IS message

  private
    U : Set
    U = SessionType √ó SessionType

  data FSubIS-RN : Set where
    nil-any end-def : FSubIS-RN
    ii oo : FSubIS-RN

  data FSubCOIS-RN : Set where
    co-conv : FSubCOIS-RN

  nil-any-r : FinMetaRule U
  nil-any-r .Ctx = SessionType
  nil-any-r .comp T =
    [] ,
    ------------------
    (nil , T)

  end-def-r : FinMetaRule U
  end-def-r .Ctx = Œ£[ (T , S) ‚àà SessionType √ó SessionType ] End T √ó Defined S
  end-def-r .comp ((T , S) , _) =
    [] ,
    ------------------
    (T , S)

  ii-r : MetaRule U
  ii-r .Ctx = Œ£[ (f , g) ‚àà Continuation √ó Continuation ] dom f ‚äÜ dom g
  ii-r .Pos ((f , _) , _) = Œ£[ t ‚àà ùïã ] t ‚àà dom f
  ii-r .prems ((f , g) , _) (t , _) = f t .force , g t .force
  ii-r .conclu ((f , g) , _) = inp f , inp g

  oo-r : MetaRule U
  oo-r .Ctx = Œ£[ (f , g) ‚àà Continuation √ó Continuation ] dom g ‚äÜ dom f √ó Witness g
  oo-r .Pos ((_ , g) , _) = Œ£[ t ‚àà ùïã ] t ‚àà dom g
  oo-r .prems ((f , g) , _) (t , _) = f t .force , g t .force
  oo-r .conclu ((f , g) , _) = out f , out g

  co-conv-r : FinMetaRule U
  co-conv-r .Ctx = Œ£[ (T , S) ‚àà SessionType √ó SessionType ] T ‚Üì S
  co-conv-r .comp ((T , S) , _) =
    [] ,
    ------------------
    (T , S)

  FSubIS : IS U
  FSubIS .Names = FSubIS-RN
  FSubIS .rules nil-any = from nil-any-r
  FSubIS .rules end-def = from end-def-r
  FSubIS .rules ii = ii-r
  FSubIS .rules oo = oo-r

  FSubCOIS : IS U
  FSubCOIS .Names = FSubCOIS-RN
  FSubCOIS .rules co-conv = from co-conv-r

  _‚â§F_ : SessionType ‚Üí SessionType ‚Üí Set
  T ‚â§F S = FCoInd‚ü¶ FSubIS , FSubCOIS ‚üß (T , S)

  _‚â§F·µ¢_ : SessionType ‚Üí SessionType ‚Üí Set
  T ‚â§F·µ¢ S = Ind‚ü¶ FSubIS ‚à™ FSubCOIS ‚üß (T , S)

  _‚â§Fc_ : SessionType ‚Üí SessionType ‚Üí Set
  T ‚â§Fc S = CoInd‚ü¶ FSubIS ‚üß (T , S)


  {- Specification using _‚ä¢_ is correct wrt FairSubtypingS -}

  FSSpec-‚ä¢ : U ‚Üí Set
  FSSpec-‚ä¢ (T , S) = ‚àÄ{R} ‚Üí R ‚ä¢ T ‚Üí R ‚ä¢ S
  
  spec-sound : ‚àÄ{T S} ‚Üí FairSubtypingS T S ‚Üí FSSpec-‚ä¢ (T , S)
  spec-sound fs fc = fc-complete (fs (fc-sound fc))

  spec-complete : ‚àÄ{T S} ‚Üí FSSpec-‚ä¢ (T , S) ‚Üí FairSubtypingS T S
  spec-complete fs fc = fc-sound (fs (fc-complete fc))

  ------------------------------------------------------

  {- Soundness -}
¬† -- Using bounded coinduction wrt SpecAux

  ‚â§F·µ¢->‚Üì : ‚àÄ{S T} ‚Üí S ‚â§F·µ¢ T ‚Üí S ‚Üì T
  ‚â§F·µ¢->‚Üì (fold (inj‚ÇÅ nil-any , _ , refl , _)) = nil-converges
  ‚â§F·µ¢->‚Üì (fold (inj‚ÇÅ end-def , (_ , (end , def)) , refl , _)) = end-converges end def
  ‚â§F·µ¢->‚Üì (fold (inj‚ÇÅ ii , _ , refl , pr)) = converge (pre-conv-inp-back Œª x ‚Üí ‚Üì->preconv (‚â§F·µ¢->‚Üì (pr (_ , x))))
  ‚â§F·µ¢->‚Üì (fold (inj‚ÇÅ oo , (_ , (incl , (t , ok-t))) , refl , pr)) = 
    converge 
      Œª _ _ ‚Üí [] , t , none , (_ , incl ok-t , step (out (incl ok-t)) refl) , (_ , ok-t , step (out ok-t) refl) , ‚â§F·µ¢->‚Üì (pr (t , ok-t))
  ‚â§F·µ¢->‚Üì (fold (inj‚ÇÇ co-conv , (_ , conv) , refl , _)) = conv

  SpecAux : U ‚Üí Set
  SpecAux (R , T) = Œ£[ S ‚àà SessionType ] S ‚â§F T √ó R ‚ä¢ S 

  ‚â§F·µ¢->defined : ‚àÄ{S T} ‚Üí Defined S ‚Üí S ‚â§F·µ¢ T ‚Üí Defined T
  ‚â§F·µ¢->defined def fs = conv->defined def (‚â§F·µ¢->‚Üì fs)

  spec-bounded-rec : ‚àÄ{R S} T ‚Üí T ‚â§F·µ¢ S ‚Üí R ‚ä¢ T ‚Üí R ‚ä¢·µ¢ S
  spec-bounded-rec _ fs fc =     
    let _ , reds , succ = con-sound (‚â§F·µ¢->‚Üì fs) (fc-sound fc) in
    maysucceed->‚ä¢·µ¢ reds succ

  spec-bounded : SpecAux ‚äÜ Œª (R , S) ‚Üí R ‚ä¢·µ¢ S
  spec-bounded (T , fs , fc) = spec-bounded-rec T (fcoind-to-ind fs) fc

  spec-cons : SpecAux ‚äÜ ISF[ FCompIS ] SpecAux
  spec-cons {(R , T)} (S , fs , fc) with fc .CoInd‚ü¶_‚üß.unfold
  spec-cons {(R , T)} (S , fs , fc) | client-end , ((_ , (win , def)) , _) , refl , _ = 
    client-end , ((R , _) , (win , ‚â§F·µ¢->defined def (fcoind-to-ind fs))) , refl , Œª ()
  spec-cons {(out r , _)} ((inp f) , fs , fc) | oi , (((.r , .f) , wit-r) , _) , refl , pr with fs .CoInd‚ü¶_‚üß.unfold
  ... | end-def , (((.(inp f) , _) , (inp e , _)) , _) , refl , _ = ‚ä•-elim (e _ (proj‚ÇÇ (fc->defined (pr wit-r))))
  ... | ii , (((.f , g) , _) , _) , refl , pr' = oi , (_ , wit-r) , refl , Œª wit ‚Üí _ , pr' (_ , proj‚ÇÇ (fc->defined (pr wit))) , pr wit
  spec-cons {(inp r , T)} (out f , fs , fc) | io , (((.r , .f) , wit-f) , _) , refl , pr with fs .CoInd‚ü¶_‚üß.unfold
  ... | end-def , (((.(out f) , _) , (out e , _)) , _) , refl , _ = ‚ä•-elim (e _ (proj‚ÇÇ wit-f))
  ... | oo , (((.f , g) , (incl , wit-g)) , _) , refl , pr' = io , (_ , wit-g) , refl , Œª wit ‚Üí _ , pr' wit , pr (_ , incl (proj‚ÇÇ wit))

  spec-aux-sound : SpecAux ‚äÜ Œª (R , S) ‚Üí R ‚ä¢ S
  spec-aux-sound = bounded-coind[ FCompIS , FCompCOIS ] SpecAux spec-bounded spec-cons

  fs-sound : ‚àÄ{T S} ‚Üí T ‚â§F S ‚Üí FSSpec-‚ä¢ (T , S)
  fs-sound {T} fs fc = spec-aux-sound (T , fs , fc)

  {- Soundness & Completeness of Sub wrt ‚â§Fc -}

  ‚â§Fc->sub : ‚àÄ{S T} ‚Üí S ‚â§Fc T ‚Üí ‚àÄ {i} ‚Üí Sub S T i
  ‚â§Fc->sub fs with fs .CoInd‚ü¶_‚üß.unfold
  ... | nil-any , _ , refl , _ = nil<:any
  ... | end-def , (_ , (end , def)) , refl , _ = end<:def end def
  ... | ii , ((f , g) , incl) , refl , pr = inp<:inp incl Œª x ‚Üí Œª where .force ‚Üí if-def x
    where 
      if-def : (t : ùïã) ‚Üí ‚àÄ{i} ‚Üí Sub (f t .force) (g t .force) i
      if-def t with t ‚àà? f
      ... | yes ok-t = ‚â§Fc->sub (pr (_ , ok-t))
      ... | no no-t = subst (Œª x ‚Üí Sub x (g t .force) _) (sym (not-def->nil no-t)) nil<:any
  ... | oo , (_ , (incl , wit)) , refl , pr = out<:out wit incl Œª ok-x ‚Üí Œª where .force ‚Üí ‚â§Fc->sub (pr (_ , ok-x))

  sub->‚â§Fc : ‚àÄ{S T} ‚Üí (‚àÄ{i} ‚Üí Sub S T i) ‚Üí S ‚â§Fc T
  CoInd‚ü¶_‚üß.unfold (sub->‚â§Fc fs) with fs
  ... | nil<:any = nil-any , _ , refl , Œª ()
  ... | end<:def end def = end-def , (_ , (end , def)) , refl , Œª ()
  ... | inp<:inp incl pr = ii , (_ , incl) , refl , Œª (p , _) ‚Üí sub->‚â§Fc (pr p .force)
  ... | out<:out wit incl pr = oo , (_ , (incl , wit)) , refl , Œª (_ , ok) ‚Üí sub->‚â§Fc (pr ok .force)

  {- Auxiliary -}

  -- Only premise for rules using sample-cont in ‚ä¢
  sample-cont-prem : ‚àÄ{f : Continuation}{t R} ‚Üí R ‚ä¢ f t .force 
    ‚Üí (pos : Œ£[ p ‚àà ùïã ] p ‚àà dom (sample-cont t R nil)) ‚Üí (sample-cont t R nil) (proj‚ÇÅ pos) .force ‚ä¢ f (proj‚ÇÅ pos) .force
  sample-cont-prem {f} {t} pr (p , ok-p) with p ?= t
  ... | yes refl = pr
  sample-cont-prem {f} {t} pr (p , ()) | no ¬¨eq

  -- Premises using sample-cont-dual in ‚ä¢
  sample-cont-prems : ‚àÄ{f : Continuation}{t} ‚Üí t ‚àâ dom f 
    ‚Üí (pos : Œ£[ p ‚àà ùïã ] p ‚àà dom f) ‚Üí (sample-cont t nil win) (proj‚ÇÅ pos) .force ‚ä¢ f (proj‚ÇÅ pos) .force
  sample-cont-prems {f} {t} no-t (p , ok-p) with p ?= t
  ... | yes refl = ‚ä•-elim (no-t ok-p)
  ... | no ¬¨eq = win‚ä¢def ok-p

  -- Premises using sample-cont-dual in ‚ä¢
  sample-cont-prems' : ‚àÄ{f : Continuation}{t R} ‚Üí R ‚ä¢ f t .force 
    ‚Üí (pos : Œ£[ p ‚àà ùïã ] p ‚àà dom f) ‚Üí (sample-cont t R win) (proj‚ÇÅ pos) .force ‚ä¢ f (proj‚ÇÅ pos) .force
  sample-cont-prems' {f} {t} pr (p , ok-p) with p ?= t
  ... | yes refl = pr
  ... | no ¬¨eq = win‚ä¢def ok-p

  spec-inp->incl : ‚àÄ{f g} ‚Üí FSSpec-‚ä¢ (inp f , inp g) ‚Üí dom f ‚äÜ dom g
  spec-inp->incl {f} {g} fs {t} ok-t with fs (apply-fcoind oi ((sample-cont t win nil , f) , wit-cont out) (sample-cont-prem {f} {t} (win‚ä¢def ok-t))) .CoInd‚ü¶_‚üß.unfold
  ... | client-end , ((_ , (out e , _)) , _) , refl , _ = ‚ä•-elim (e t (proj‚ÇÇ (wit-cont out)))
  ... | oi , _ , refl , pr = proj‚ÇÇ (fc->defined (pr (t , proj‚ÇÇ (wit-cont out))))

  spec-out->incl : ‚àÄ{f g} ‚Üí FSSpec-‚ä¢ (out f , out g) ‚Üí Witness f ‚Üí dom g ‚äÜ dom f
  spec-out->incl {f} {g} fs wit {t} ok-t with t ‚àà? f
  ... | yes ok = ok
  ... | no no-t with (fs (apply-fcoind io ((sample-cont t nil win ,  f) , wit) (sample-cont-prems {f} {t} no-t))) .CoInd‚ü¶_‚üß.unfold
  ... | client-end , ((_ , (() , _)) , _) , refl , _
  ... | io , _ , refl , pr = ‚ä•-elim (cont-not-def (proj‚ÇÅ (fc->defined (pr (t , ok-t)))))

  spec-out->wit : ‚àÄ{f g} ‚Üí Witness f ‚Üí  FSSpec-‚ä¢ (out f , out g) ‚Üí Witness g
  spec-out->wit {f} {g} wit-f fs with Empty? g
  ... | inj‚ÇÇ wit = wit
  ... | inj‚ÇÅ e with (fs (apply-fcoind io ((full-cont win , f) , wit-f) Œª (_ , ok) ‚Üí win‚ä¢def ok)) .CoInd‚ü¶_‚üß.unfold 
  ... | client-end , ((_ , (() , _)) , _) , refl , _
  ... | io , ((_ , wit-g) , _) , refl , _ = ‚ä•-elim (e _ (proj‚ÇÇ wit-g))
  
  {- Boundedness & Consistency -}
  
  fsspec-cons : FSSpec-‚ä¢ ‚äÜ ISF[ FSubIS ] FSSpec-‚ä¢
  fsspec-cons {nil , T} fs = nil-any , _ , refl , Œª ()
  fsspec-cons {inp f , nil} fs with (fs (apply-fcoind client-end ((win , _) , (Win-win , inp)) Œª ())) .CoInd‚ü¶_‚üß.unfold
  ... | client-end , ((_ , (_ , ())) , _) , refl , _
  fsspec-cons {inp f , inp g} fs = ii , ((f , g) , spec-inp->incl fs) , refl , 
    Œª (p , _) {R} fc-r-f ‚Üí 
      let wit = wit-cont (proj‚ÇÅ (fc->defined fc-r-f)) in
      let fc-Or-Ig = fs (apply-fcoind oi ((sample-cont p R nil , f) , wit) (sample-cont-prem {f} {p} fc-r-f)) in
      let fc-r-g = ‚ä¢-after-out {sample-cont p R nil} {g} {p} (proj‚ÇÇ wit) fc-Or-Ig in
      subst (Œª x ‚Üí x ‚ä¢ g p .force) (sym force-eq) fc-r-g
  fsspec-cons {inp f , out g} fs with Empty? f
  ... | inj‚ÇÅ e = end-def , (_ , (inp e , out)) , refl , Œª ()
  ... | inj‚ÇÇ (t , ok-t) with (fs (apply-fcoind oi ((sample-cont t win nil , f) , wit-cont out) (sample-cont-prem {f} {t} (win‚ä¢def ok-t)))) .CoInd‚ü¶_‚üß.unfold
  ... | client-end , ((_ , (out e , out)) , _) , refl , _ = ‚ä•-elim (e t (proj‚ÇÇ (wit-cont out)))
  fsspec-cons {out f , nil} fs with (fs (apply-fcoind client-end ((win , _) , (Win-win , out)) Œª ())) .CoInd‚ü¶_‚üß.unfold
  ... | client-end , ((_ , (_ , ())) , _) , refl , _
  fsspec-cons {out f , inp g} fs with Empty? f
  ... | inj‚ÇÅ e = end-def , (_ , (out e , inp)) , refl , Œª ()
  ... | inj‚ÇÇ (t , ok-t) with (fs (apply-fcoind io ((full-cont win , f) , (t , ok-t)) Œª (_ , ok-p) ‚Üí win‚ä¢def ok-p)) .CoInd‚ü¶_‚üß.unfold
  ... | client-end , ((_ , (() , inp)) , _) , refl , _
  fsspec-cons {out f , out g} fs with Empty? f
  ... | inj‚ÇÅ e = end-def , (_ , (out e , out)) , refl , Œª ()
  ... | inj‚ÇÇ (t , ok-t) = 
    let wit-g = spec-out->wit (t , ok-t) fs in
    let incl = spec-out->incl fs (t , ok-t) in 
    oo , ((f , g) , (incl , wit-g)) , refl , Œª (p , ok-p) {R} fc-r-f ‚Üí 
      let fc-Ir-Og = fs (apply-fcoind io ((sample-cont p R win , f) , (t , ok-t)) (sample-cont-prems' {f} {p} fc-r-f)) in
      let fc-r-g = ‚ä¢-after-in {sample-cont p R win} {g} {p} ok-p fc-Ir-Og in
      subst (Œª x ‚Üí x ‚ä¢ g p .force) (sym force-eq) fc-r-g

  fsspec->sub : ‚àÄ{S T} ‚Üí FSSpec-‚ä¢ (S , T) ‚Üí S ‚â§Fc T
  fsspec->sub = coind[ FSubIS ] FSSpec-‚ä¢ fsspec-cons

  postulate
    not-conv-div : ‚àÄ{T S} ‚Üí ¬¨ T ‚Üì S ‚Üí T ‚Üë S

  fs-convergence : ‚àÄ{T S} ‚Üí FairSubtypingS T S ‚Üí T ‚Üì S
  fs-convergence {T} {S} fs with Common.excluded-middle {T ‚Üì S}
  fs-convergence {T} {S} fs | yes p = p
  fs-convergence {T} {S} fs | no p =
    let div = not-conv-div p in
    let sub = ‚â§Fc->sub (fsspec->sub (spec-sound fs)) in
    let d-comp = discriminator-compliant sub div in
    let ¬¨d-comp = discriminator-not-compliant sub div in
    ‚ä•-elim (¬¨d-comp (fs d-comp))
  
  fsspec-bounded : ‚àÄ{S T} ‚Üí FSSpec-‚ä¢ (S , T) ‚Üí S ‚â§F·µ¢ T
  fsspec-bounded fs = apply-ind (inj‚ÇÇ co-conv) (_ , (fs-convergence (spec-complete fs))) Œª ()

  {- Completeness -}

  fs-complete : ‚àÄ{S T} ‚Üí FSSpec-‚ä¢ (S , T) ‚Üí S ‚â§F T
  fs-complete = bounded-coind[ FSubIS , FSubCOIS ] FSSpec-‚ä¢ fsspec-bounded fsspec-cons